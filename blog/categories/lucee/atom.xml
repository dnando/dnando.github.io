<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Lucee | Nando @ Aria Media]]></title>
  <link href="http://dnando.github.io/blog/categories/lucee/atom.xml" rel="self"/>
  <link href="http://dnando.github.io/"/>
  <updated>2015-07-03T16:00:49+02:00</updated>
  <id>http://dnando.github.io/</id>
  <author>
    <name><![CDATA[Nando @ Aria Media]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CFML Queries in Script]]></title>
    <link href="http://dnando.github.io/blog/2015/06/16/cfml-queries-in-script/"/>
    <updated>2015-06-16T18:39:54+02:00</updated>
    <id>http://dnando.github.io/blog/2015/06/16/cfml-queries-in-script</id>
    <content type="html"><![CDATA[<p>Recently, I needed to write a somewhat complex query with a conditional where clause. I resisted the urge to revert to the cfquery tag for this sort of thing, and came up with the following using queryExecute(), submitted as an example without explanation. This approach works on both ACF and Lucee.</p>

<pre><code>public query function findRawAudit( string entity, numeric userId, date dateFrom, date dateTo, numeric timeZoneOffset ) {
    var newLine = CHR(13) &amp; CHR(10);
    var params = {};
    var sql = "
        select a.entity, a.entityId, a.timestamp, a.transaction, a.attribute, a.value as previousValue, u.name as username, null as currentValue, null as auditName, null as asql
        from Audit a inner join User u
        on a.userId = u.userId
        where 0=0
    ";

    if ( structKeyExists(arguments, 'entity') and len( arguments.entity ) ) {
        sql &amp;= newLine &amp; "and entity = :entity";
        structInsert(params, "entity", { value: arguments.entity, cfsqltype: "cf_sql_varchar" } );
    }

    if ( structKeyExists(arguments, 'userId') ) {
        sql &amp;= newLine &amp; "and a.userId = :userId";
        structInsert(params, "userId", { value: arguments.userId, cfsqltype: "cf_sql_integer" } );
    }

    if ( structKeyExists(arguments, 'dateFrom') ) {
        sql &amp;= newLine &amp; "and timestamp &gt; :dateFrom";
        //  adjust dateFrom to account for time zone difference between server and user
        var dateFromUTC = DateAdd( 'h', -arguments.timeZoneOffset, arguments.dateFrom );
        structInsert(params, "dateFrom", { value: arguments.dateFrom, cfsqltype: "cf_sql_timestamp" } );
    }

    if ( structKeyExists(arguments, 'dateTo') ) {
        sql &amp;= newLine &amp; "and timestamp &lt; :dateTo";
        //  adjust dateFrom to account for time zone difference between server and user
        var dateToUTC = DateAdd( 'h', -arguments.timeZoneOffset, arguments.dateTo );
        // we add a day to dateTo to arrive at an effectiveEndDateTime, namely midnight of the endDate
        // so that the endDate is inclusive, as users would very likely expect
        dateToUTC = dateAdd( 'd', 1, dateToUTC );
        // stdout.println( "dateToUTC : #dateToUTC #" );
        structInsert(params, "dateTo", { value: dateToUTC, cfsqltype: "cf_sql_timestamp" } );
    }

    sql &amp;= newLine &amp; "and a.attribute != 'version' ";

    sql &amp;= newLine &amp; "and a.attribute != 'lastEdited' ";

    sql &amp;= newLine &amp; "and a.attribute != 'userId' ";

    sql &amp;= newLine &amp; "order by a.timestamp desc, a.transaction";

    return queryExecute( sql, params );
}
</code></pre>

<p>Thanks to Igal Sapir for helping me work this out!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debugging Technique CFML Development]]></title>
    <link href="http://dnando.github.io/blog/2015/06/16/debugging-technique-cfml-development/"/>
    <updated>2015-06-16T17:01:52+02:00</updated>
    <id>http://dnando.github.io/blog/2015/06/16/debugging-technique-cfml-development</id>
    <content type="html"><![CDATA[<p>I learned a debugging techique from Sean Corfield recently that I think is well worth sharing more widely. It works just as well for Lucee, Railo or Adobe Coldfusion. Here&rsquo;s what he reccommends:</p>

<p><blockquote><p>For ease of debugging any problems that may occur, I strongly recommend you always keep a Terminal / Console window open containing a tail of the console output from your CFML server. If you’re using Lucee or a Railo installation based on Tomcat, you’ll want to find the catalina.out log file and tail that. If you’re using ColdFusion 11, even tho’ it is notionally based on Tomcat, it’s completely non-standard and you’ll want to tail cfusion/logs/coldfusion-out.log.</p><footer><strong>Sean Corfield <a href="https://framework-one.github.io/documentation/3.5/cfml-and-clojure.html">https://framework-one.github.io/documentation/3.5/cfml-and-clojure.html</a></strong></footer></blockquote></p>

<p>To &ldquo;tail&rdquo;, in this case, means to show the newly added contents of a log file in real time. To get this to work, I open Terminal on my Mac and issue the following commands:</p>

<p> &hellip; for my local CF11 install:</p>

<pre><code class="`"> tail -f /Applications/ColdFusion11/cfusion/logs/coldfusion-out.log
</code></pre>

<p>  and for my local Lucee install:</p>

<pre><code class="``">  tail -f ~/tomcat/logs/catalina.out
</code></pre>

<p>  You will of course need to change those paths to match the directory under which your applications are installed.</p>

<p>  To get out of tail mode and back to the command line, hit CTRL-C.</p>

<p>  What I see when I do this is the last 10 lines of the log file, to start with. Anytime an additional line is added to the log file, it immediately appears in the console display in real time.</p>

<p>  Now what I can do in my code is send output to these log files. An example should explain it sufficiently. I just used this technique to debug a the following service function, where I wanted to ensure that dateTo UTC was being set as needed:</p>

<pre><code class="``">    public query function findRawAudit( string entity, numeric userId, date dateFrom, date dateTo, numeric timeZoneOffset ) {
        var stdout = createObject( "java", "java.lang.System" ).out;

        ...

        if ( structKeyExists(arguments, 'dateTo') ) {
            sql &amp;= "#newLine#" &amp; "and timestamp &lt; :dateTo";
            //  adjust dateFrom to account for time zone difference between server and user
            var dateToUTC = DateAdd( 'h', -arguments.timeZoneOffset, arguments.dateTo );
            // we add a day to dateTo to arrive at an effectiveEndDateTime, namely midnight of the endDate
            // so that the endDate is inclusive, as users would very likely expect
            dateToUTC = dateAdd( 'd', 1, dateToUTC );
            stdout.println( "dateToUTC : #dateToUTC #" );
            structInsert(params, "dateTo", { value: dateToUTC, cfsqltype: "cf_sql_timestamp" } );
        }
        ...
    }
</code></pre>

<p>Note the lines <code>var stdout = createObject( "java", "java.lang.System" ).out;</code> and <code>stdout.println( "dateToUTC : #dateToUTC #" );</code> which creates an instance of java.lang.System.out and prints a line to the log file.</p>

<p>Immediately upon running this code <code>dateToUTC : {ts '2015-06-16 22:00:00'}</code> appeared in my tail output, which is what I expected. The bug was elsewhere, . I find this very useful. It&rsquo;s simple and effective, and it works in the same way across ACF, Lucee and Railo. I don&rsquo;t have to fiddle around with an admin setting to turn on trace output, check if trace output is enabled, remember the syntax used for cftrace / trace, and I can use it directly on a production server in a pinch in case of need.</p>

<p>Of course, you can tail any log file necessary, or use WriteLog() or Trace() if you prefer.</p>
]]></content>
  </entry>
  
</feed>
